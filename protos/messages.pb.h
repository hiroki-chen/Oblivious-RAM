// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace oram_impl {
class FlatVectorMessage;
struct FlatVectorMessageDefaultTypeInternal;
extern FlatVectorMessageDefaultTypeInternal _FlatVectorMessage_default_instance_;
class HelloMessage;
struct HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class InitFlatOramRequest;
struct InitFlatOramRequestDefaultTypeInternal;
extern InitFlatOramRequestDefaultTypeInternal _InitFlatOramRequest_default_instance_;
class InitSqrtOramRequest;
struct InitSqrtOramRequestDefaultTypeInternal;
extern InitSqrtOramRequestDefaultTypeInternal _InitSqrtOramRequest_default_instance_;
class InitTreeOramRequest;
struct InitTreeOramRequestDefaultTypeInternal;
extern InitTreeOramRequestDefaultTypeInternal _InitTreeOramRequest_default_instance_;
class KeyExchangeRequest;
struct KeyExchangeRequestDefaultTypeInternal;
extern KeyExchangeRequestDefaultTypeInternal _KeyExchangeRequest_default_instance_;
class KeyExchangeResponse;
struct KeyExchangeResponseDefaultTypeInternal;
extern KeyExchangeResponseDefaultTypeInternal _KeyExchangeResponse_default_instance_;
class PrintOramTreeRequest;
struct PrintOramTreeRequestDefaultTypeInternal;
extern PrintOramTreeRequestDefaultTypeInternal _PrintOramTreeRequest_default_instance_;
class ReadFlatRequest;
struct ReadFlatRequestDefaultTypeInternal;
extern ReadFlatRequestDefaultTypeInternal _ReadFlatRequest_default_instance_;
class ReadPathRequest;
struct ReadPathRequestDefaultTypeInternal;
extern ReadPathRequestDefaultTypeInternal _ReadPathRequest_default_instance_;
class ReadPathResponse;
struct ReadPathResponseDefaultTypeInternal;
extern ReadPathResponseDefaultTypeInternal _ReadPathResponse_default_instance_;
class ReadSqrtRequest;
struct ReadSqrtRequestDefaultTypeInternal;
extern ReadSqrtRequestDefaultTypeInternal _ReadSqrtRequest_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class SqrtMessage;
struct SqrtMessageDefaultTypeInternal;
extern SqrtMessageDefaultTypeInternal _SqrtMessage_default_instance_;
class SqrtPermMessage;
struct SqrtPermMessageDefaultTypeInternal;
extern SqrtPermMessageDefaultTypeInternal _SqrtPermMessage_default_instance_;
class WritePathRequest;
struct WritePathRequestDefaultTypeInternal;
extern WritePathRequestDefaultTypeInternal _WritePathRequest_default_instance_;
class WritePathResponse;
struct WritePathResponseDefaultTypeInternal;
extern WritePathResponseDefaultTypeInternal _WritePathResponse_default_instance_;
class WriteSqrtMessage;
struct WriteSqrtMessageDefaultTypeInternal;
extern WriteSqrtMessageDefaultTypeInternal _WriteSqrtMessage_default_instance_;
}  // namespace oram_impl
PROTOBUF_NAMESPACE_OPEN
template<> ::oram_impl::FlatVectorMessage* Arena::CreateMaybeMessage<::oram_impl::FlatVectorMessage>(Arena*);
template<> ::oram_impl::HelloMessage* Arena::CreateMaybeMessage<::oram_impl::HelloMessage>(Arena*);
template<> ::oram_impl::InitFlatOramRequest* Arena::CreateMaybeMessage<::oram_impl::InitFlatOramRequest>(Arena*);
template<> ::oram_impl::InitSqrtOramRequest* Arena::CreateMaybeMessage<::oram_impl::InitSqrtOramRequest>(Arena*);
template<> ::oram_impl::InitTreeOramRequest* Arena::CreateMaybeMessage<::oram_impl::InitTreeOramRequest>(Arena*);
template<> ::oram_impl::KeyExchangeRequest* Arena::CreateMaybeMessage<::oram_impl::KeyExchangeRequest>(Arena*);
template<> ::oram_impl::KeyExchangeResponse* Arena::CreateMaybeMessage<::oram_impl::KeyExchangeResponse>(Arena*);
template<> ::oram_impl::PrintOramTreeRequest* Arena::CreateMaybeMessage<::oram_impl::PrintOramTreeRequest>(Arena*);
template<> ::oram_impl::ReadFlatRequest* Arena::CreateMaybeMessage<::oram_impl::ReadFlatRequest>(Arena*);
template<> ::oram_impl::ReadPathRequest* Arena::CreateMaybeMessage<::oram_impl::ReadPathRequest>(Arena*);
template<> ::oram_impl::ReadPathResponse* Arena::CreateMaybeMessage<::oram_impl::ReadPathResponse>(Arena*);
template<> ::oram_impl::ReadSqrtRequest* Arena::CreateMaybeMessage<::oram_impl::ReadSqrtRequest>(Arena*);
template<> ::oram_impl::RequestHeader* Arena::CreateMaybeMessage<::oram_impl::RequestHeader>(Arena*);
template<> ::oram_impl::SqrtMessage* Arena::CreateMaybeMessage<::oram_impl::SqrtMessage>(Arena*);
template<> ::oram_impl::SqrtPermMessage* Arena::CreateMaybeMessage<::oram_impl::SqrtPermMessage>(Arena*);
template<> ::oram_impl::WritePathRequest* Arena::CreateMaybeMessage<::oram_impl::WritePathRequest>(Arena*);
template<> ::oram_impl::WritePathResponse* Arena::CreateMaybeMessage<::oram_impl::WritePathResponse>(Arena*);
template<> ::oram_impl::WriteSqrtMessage* Arena::CreateMaybeMessage<::oram_impl::WriteSqrtMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace oram_impl {

enum Type : int {
  kSequential = 0,
  kRandom = 1,
  kInit = 2,
  kNormal = 3,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = kSequential;
constexpr Type Type_MAX = kNormal;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHeader& from) {
    RequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceHashFieldNumber = 1,
    kVersionFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // bytes instance_hash = 1;
  void clear_instance_hash();
  const std::string& instance_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_hash();
  PROTOBUF_NODISCARD std::string* release_instance_hash();
  void set_allocated_instance_hash(std::string* instance_hash);
  private:
  const std::string& _internal_instance_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_hash(const std::string& value);
  std::string* _internal_mutable_instance_hash();
  public:

  // bytes version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint32 id = 3;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class PrintOramTreeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.PrintOramTreeRequest) */ {
 public:
  inline PrintOramTreeRequest() : PrintOramTreeRequest(nullptr) {}
  ~PrintOramTreeRequest() override;
  explicit PROTOBUF_CONSTEXPR PrintOramTreeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintOramTreeRequest(const PrintOramTreeRequest& from);
  PrintOramTreeRequest(PrintOramTreeRequest&& from) noexcept
    : PrintOramTreeRequest() {
    *this = ::std::move(from);
  }

  inline PrintOramTreeRequest& operator=(const PrintOramTreeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintOramTreeRequest& operator=(PrintOramTreeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrintOramTreeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintOramTreeRequest* internal_default_instance() {
    return reinterpret_cast<const PrintOramTreeRequest*>(
               &_PrintOramTreeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PrintOramTreeRequest& a, PrintOramTreeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintOramTreeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintOramTreeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintOramTreeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintOramTreeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrintOramTreeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrintOramTreeRequest& from) {
    PrintOramTreeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrintOramTreeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.PrintOramTreeRequest";
  }
  protected:
  explicit PrintOramTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.PrintOramTreeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class HelloMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.HelloMessage) */ {
 public:
  inline HelloMessage() : HelloMessage(nullptr) {}
  ~HelloMessage() override;
  explicit PROTOBUF_CONSTEXPR HelloMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage(const HelloMessage& from);
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloMessage& from) {
    HelloMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.HelloMessage";
  }
  protected:
  explicit HelloMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kIvFieldNumber = 2,
  };
  // bytes content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // bytes iv = 2;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.HelloMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class KeyExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.KeyExchangeRequest) */ {
 public:
  inline KeyExchangeRequest() : KeyExchangeRequest(nullptr) {}
  ~KeyExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyExchangeRequest(const KeyExchangeRequest& from);
  KeyExchangeRequest(KeyExchangeRequest&& from) noexcept
    : KeyExchangeRequest() {
    *this = ::std::move(from);
  }

  inline KeyExchangeRequest& operator=(const KeyExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyExchangeRequest& operator=(KeyExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const KeyExchangeRequest*>(
               &_KeyExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyExchangeRequest& a, KeyExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyExchangeRequest& from) {
    KeyExchangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.KeyExchangeRequest";
  }
  protected:
  explicit KeyExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyClientFieldNumber = 1,
  };
  // bytes public_key_client = 1;
  void clear_public_key_client();
  const std::string& public_key_client() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_client(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_client();
  PROTOBUF_NODISCARD std::string* release_public_key_client();
  void set_allocated_public_key_client(std::string* public_key_client);
  private:
  const std::string& _internal_public_key_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_client(const std::string& value);
  std::string* _internal_mutable_public_key_client();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.KeyExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_client_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class KeyExchangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.KeyExchangeResponse) */ {
 public:
  inline KeyExchangeResponse() : KeyExchangeResponse(nullptr) {}
  ~KeyExchangeResponse() override;
  explicit PROTOBUF_CONSTEXPR KeyExchangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyExchangeResponse(const KeyExchangeResponse& from);
  KeyExchangeResponse(KeyExchangeResponse&& from) noexcept
    : KeyExchangeResponse() {
    *this = ::std::move(from);
  }

  inline KeyExchangeResponse& operator=(const KeyExchangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyExchangeResponse& operator=(KeyExchangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyExchangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyExchangeResponse* internal_default_instance() {
    return reinterpret_cast<const KeyExchangeResponse*>(
               &_KeyExchangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeyExchangeResponse& a, KeyExchangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyExchangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyExchangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyExchangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyExchangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyExchangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyExchangeResponse& from) {
    KeyExchangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyExchangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.KeyExchangeResponse";
  }
  protected:
  explicit KeyExchangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyServerFieldNumber = 1,
  };
  // bytes public_key_server = 1;
  void clear_public_key_server();
  const std::string& public_key_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_server();
  PROTOBUF_NODISCARD std::string* release_public_key_server();
  void set_allocated_public_key_server(std::string* public_key_server);
  private:
  const std::string& _internal_public_key_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_server(const std::string& value);
  std::string* _internal_mutable_public_key_server();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.KeyExchangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_server_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitFlatOramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.InitFlatOramRequest) */ {
 public:
  inline InitFlatOramRequest() : InitFlatOramRequest(nullptr) {}
  ~InitFlatOramRequest() override;
  explicit PROTOBUF_CONSTEXPR InitFlatOramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitFlatOramRequest(const InitFlatOramRequest& from);
  InitFlatOramRequest(InitFlatOramRequest&& from) noexcept
    : InitFlatOramRequest() {
    *this = ::std::move(from);
  }

  inline InitFlatOramRequest& operator=(const InitFlatOramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitFlatOramRequest& operator=(InitFlatOramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitFlatOramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitFlatOramRequest* internal_default_instance() {
    return reinterpret_cast<const InitFlatOramRequest*>(
               &_InitFlatOramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InitFlatOramRequest& a, InitFlatOramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitFlatOramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitFlatOramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitFlatOramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitFlatOramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitFlatOramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitFlatOramRequest& from) {
    InitFlatOramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitFlatOramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.InitFlatOramRequest";
  }
  protected:
  explicit InitFlatOramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kBlockSizeFieldNumber = 3,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 capacity = 2;
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // uint32 block_size = 3;
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.InitFlatOramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    uint32_t capacity_;
    uint32_t block_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitSqrtOramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.InitSqrtOramRequest) */ {
 public:
  inline InitSqrtOramRequest() : InitSqrtOramRequest(nullptr) {}
  ~InitSqrtOramRequest() override;
  explicit PROTOBUF_CONSTEXPR InitSqrtOramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitSqrtOramRequest(const InitSqrtOramRequest& from);
  InitSqrtOramRequest(InitSqrtOramRequest&& from) noexcept
    : InitSqrtOramRequest() {
    *this = ::std::move(from);
  }

  inline InitSqrtOramRequest& operator=(const InitSqrtOramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSqrtOramRequest& operator=(InitSqrtOramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSqrtOramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSqrtOramRequest* internal_default_instance() {
    return reinterpret_cast<const InitSqrtOramRequest*>(
               &_InitSqrtOramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InitSqrtOramRequest& a, InitSqrtOramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSqrtOramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSqrtOramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSqrtOramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSqrtOramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitSqrtOramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitSqrtOramRequest& from) {
    InitSqrtOramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitSqrtOramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.InitSqrtOramRequest";
  }
  protected:
  explicit InitSqrtOramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kSquaredMFieldNumber = 3,
    kBlockSizeFieldNumber = 4,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 capacity = 2;
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // uint32 squared_m = 3;
  void clear_squared_m();
  uint32_t squared_m() const;
  void set_squared_m(uint32_t value);
  private:
  uint32_t _internal_squared_m() const;
  void _internal_set_squared_m(uint32_t value);
  public:

  // uint32 block_size = 4;
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.InitSqrtOramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    uint32_t capacity_;
    uint32_t squared_m_;
    uint32_t block_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlatVectorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.FlatVectorMessage) */ {
 public:
  inline FlatVectorMessage() : FlatVectorMessage(nullptr) {}
  ~FlatVectorMessage() override;
  explicit PROTOBUF_CONSTEXPR FlatVectorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlatVectorMessage(const FlatVectorMessage& from);
  FlatVectorMessage(FlatVectorMessage&& from) noexcept
    : FlatVectorMessage() {
    *this = ::std::move(from);
  }

  inline FlatVectorMessage& operator=(const FlatVectorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlatVectorMessage& operator=(FlatVectorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlatVectorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlatVectorMessage* internal_default_instance() {
    return reinterpret_cast<const FlatVectorMessage*>(
               &_FlatVectorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FlatVectorMessage& a, FlatVectorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FlatVectorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlatVectorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlatVectorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlatVectorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlatVectorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlatVectorMessage& from) {
    FlatVectorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlatVectorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.FlatVectorMessage";
  }
  protected:
  explicit FlatVectorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:oram_impl.FlatVectorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::oram_impl::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SqrtMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.SqrtMessage) */ {
 public:
  inline SqrtMessage() : SqrtMessage(nullptr) {}
  ~SqrtMessage() override;
  explicit PROTOBUF_CONSTEXPR SqrtMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqrtMessage(const SqrtMessage& from);
  SqrtMessage(SqrtMessage&& from) noexcept
    : SqrtMessage() {
    *this = ::std::move(from);
  }

  inline SqrtMessage& operator=(const SqrtMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqrtMessage& operator=(SqrtMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SqrtMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqrtMessage* internal_default_instance() {
    return reinterpret_cast<const SqrtMessage*>(
               &_SqrtMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SqrtMessage& a, SqrtMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SqrtMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqrtMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqrtMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqrtMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SqrtMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SqrtMessage& from) {
    SqrtMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SqrtMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.SqrtMessage";
  }
  protected:
  explicit SqrtMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:oram_impl.SqrtMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::oram_impl::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WriteSqrtMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.WriteSqrtMessage) */ {
 public:
  inline WriteSqrtMessage() : WriteSqrtMessage(nullptr) {}
  ~WriteSqrtMessage() override;
  explicit PROTOBUF_CONSTEXPR WriteSqrtMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteSqrtMessage(const WriteSqrtMessage& from);
  WriteSqrtMessage(WriteSqrtMessage&& from) noexcept
    : WriteSqrtMessage() {
    *this = ::std::move(from);
  }

  inline WriteSqrtMessage& operator=(const WriteSqrtMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteSqrtMessage& operator=(WriteSqrtMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteSqrtMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteSqrtMessage* internal_default_instance() {
    return reinterpret_cast<const WriteSqrtMessage*>(
               &_WriteSqrtMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WriteSqrtMessage& a, WriteSqrtMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteSqrtMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteSqrtMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteSqrtMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteSqrtMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteSqrtMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteSqrtMessage& from) {
    WriteSqrtMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteSqrtMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.WriteSqrtMessage";
  }
  protected:
  explicit WriteSqrtMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kWriteToCacheFieldNumber = 3,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // bool write_to_cache = 3;
  void clear_write_to_cache();
  bool write_to_cache() const;
  void set_write_to_cache(bool value);
  private:
  bool _internal_write_to_cache() const;
  void _internal_set_write_to_cache(bool value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.WriteSqrtMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::oram_impl::RequestHeader* header_;
    bool write_to_cache_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SqrtPermMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.SqrtPermMessage) */ {
 public:
  inline SqrtPermMessage() : SqrtPermMessage(nullptr) {}
  ~SqrtPermMessage() override;
  explicit PROTOBUF_CONSTEXPR SqrtPermMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqrtPermMessage(const SqrtPermMessage& from);
  SqrtPermMessage(SqrtPermMessage&& from) noexcept
    : SqrtPermMessage() {
    *this = ::std::move(from);
  }

  inline SqrtPermMessage& operator=(const SqrtPermMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqrtPermMessage& operator=(SqrtPermMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SqrtPermMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqrtPermMessage* internal_default_instance() {
    return reinterpret_cast<const SqrtPermMessage*>(
               &_SqrtPermMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SqrtPermMessage& a, SqrtPermMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SqrtPermMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqrtPermMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqrtPermMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqrtPermMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SqrtPermMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SqrtPermMessage& from) {
    SqrtPermMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SqrtPermMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.SqrtPermMessage";
  }
  protected:
  explicit SqrtPermMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated bytes content = 2;
  int content_size() const;
  private:
  int _internal_content_size() const;
  public:
  void clear_content();
  const std::string& content(int index) const;
  std::string* mutable_content(int index);
  void set_content(int index, const std::string& value);
  void set_content(int index, std::string&& value);
  void set_content(int index, const char* value);
  void set_content(int index, const void* value, size_t size);
  std::string* add_content();
  void add_content(const std::string& value);
  void add_content(std::string&& value);
  void add_content(const char* value);
  void add_content(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& content() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_content();
  private:
  const std::string& _internal_content(int index) const;
  std::string* _internal_add_content();
  public:

  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:oram_impl.SqrtPermMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> content_;
    ::oram_impl::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitTreeOramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.InitTreeOramRequest) */ {
 public:
  inline InitTreeOramRequest() : InitTreeOramRequest(nullptr) {}
  ~InitTreeOramRequest() override;
  explicit PROTOBUF_CONSTEXPR InitTreeOramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitTreeOramRequest(const InitTreeOramRequest& from);
  InitTreeOramRequest(InitTreeOramRequest&& from) noexcept
    : InitTreeOramRequest() {
    *this = ::std::move(from);
  }

  inline InitTreeOramRequest& operator=(const InitTreeOramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitTreeOramRequest& operator=(InitTreeOramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitTreeOramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitTreeOramRequest* internal_default_instance() {
    return reinterpret_cast<const InitTreeOramRequest*>(
               &_InitTreeOramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InitTreeOramRequest& a, InitTreeOramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitTreeOramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitTreeOramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitTreeOramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitTreeOramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitTreeOramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitTreeOramRequest& from) {
    InitTreeOramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitTreeOramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.InitTreeOramRequest";
  }
  protected:
  explicit InitTreeOramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kBucketSizeFieldNumber = 2,
    kBucketNumFieldNumber = 3,
    kBlockSizeFieldNumber = 4,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 bucket_size = 2;
  void clear_bucket_size();
  uint32_t bucket_size() const;
  void set_bucket_size(uint32_t value);
  private:
  uint32_t _internal_bucket_size() const;
  void _internal_set_bucket_size(uint32_t value);
  public:

  // uint32 bucket_num = 3;
  void clear_bucket_num();
  uint32_t bucket_num() const;
  void set_bucket_num(uint32_t value);
  private:
  uint32_t _internal_bucket_num() const;
  void _internal_set_bucket_num(uint32_t value);
  public:

  // uint32 block_size = 4;
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.InitTreeOramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    uint32_t bucket_size_;
    uint32_t bucket_num_;
    uint32_t block_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadFlatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadFlatRequest) */ {
 public:
  inline ReadFlatRequest() : ReadFlatRequest(nullptr) {}
  ~ReadFlatRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadFlatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFlatRequest(const ReadFlatRequest& from);
  ReadFlatRequest(ReadFlatRequest&& from) noexcept
    : ReadFlatRequest() {
    *this = ::std::move(from);
  }

  inline ReadFlatRequest& operator=(const ReadFlatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFlatRequest& operator=(ReadFlatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFlatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFlatRequest* internal_default_instance() {
    return reinterpret_cast<const ReadFlatRequest*>(
               &_ReadFlatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReadFlatRequest& a, ReadFlatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFlatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFlatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFlatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFlatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFlatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadFlatRequest& from) {
    ReadFlatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFlatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadFlatRequest";
  }
  protected:
  explicit ReadFlatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:oram_impl.ReadFlatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadSqrtRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadSqrtRequest) */ {
 public:
  inline ReadSqrtRequest() : ReadSqrtRequest(nullptr) {}
  ~ReadSqrtRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadSqrtRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadSqrtRequest(const ReadSqrtRequest& from);
  ReadSqrtRequest(ReadSqrtRequest&& from) noexcept
    : ReadSqrtRequest() {
    *this = ::std::move(from);
  }

  inline ReadSqrtRequest& operator=(const ReadSqrtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadSqrtRequest& operator=(ReadSqrtRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadSqrtRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadSqrtRequest* internal_default_instance() {
    return reinterpret_cast<const ReadSqrtRequest*>(
               &_ReadSqrtRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReadSqrtRequest& a, ReadSqrtRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadSqrtRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadSqrtRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadSqrtRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadSqrtRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadSqrtRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadSqrtRequest& from) {
    ReadSqrtRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadSqrtRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadSqrtRequest";
  }
  protected:
  explicit ReadSqrtRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTagFieldNumber = 2,
    kReadFromFieldNumber = 3,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 tag = 2;
  void clear_tag();
  uint32_t tag() const;
  void set_tag(uint32_t value);
  private:
  uint32_t _internal_tag() const;
  void _internal_set_tag(uint32_t value);
  public:

  // uint32 read_from = 3;
  void clear_read_from();
  uint32_t read_from() const;
  void set_read_from(uint32_t value);
  private:
  uint32_t _internal_read_from() const;
  void _internal_set_read_from(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadSqrtRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    uint32_t tag_;
    uint32_t read_from_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadPathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadPathRequest) */ {
 public:
  inline ReadPathRequest() : ReadPathRequest(nullptr) {}
  ~ReadPathRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadPathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadPathRequest(const ReadPathRequest& from);
  ReadPathRequest(ReadPathRequest&& from) noexcept
    : ReadPathRequest() {
    *this = ::std::move(from);
  }

  inline ReadPathRequest& operator=(const ReadPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadPathRequest& operator=(ReadPathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadPathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadPathRequest* internal_default_instance() {
    return reinterpret_cast<const ReadPathRequest*>(
               &_ReadPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadPathRequest& a, ReadPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadPathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadPathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadPathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadPathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadPathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadPathRequest& from) {
    ReadPathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadPathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadPathRequest";
  }
  protected:
  explicit ReadPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPathFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 path = 2;
  void clear_path();
  uint32_t path() const;
  void set_path(uint32_t value);
  private:
  uint32_t _internal_path() const;
  void _internal_set_path(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadPathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::oram_impl::RequestHeader* header_;
    uint32_t path_;
    uint32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadPathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadPathResponse) */ {
 public:
  inline ReadPathResponse() : ReadPathResponse(nullptr) {}
  ~ReadPathResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadPathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadPathResponse(const ReadPathResponse& from);
  ReadPathResponse(ReadPathResponse&& from) noexcept
    : ReadPathResponse() {
    *this = ::std::move(from);
  }

  inline ReadPathResponse& operator=(const ReadPathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadPathResponse& operator=(ReadPathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadPathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadPathResponse* internal_default_instance() {
    return reinterpret_cast<const ReadPathResponse*>(
               &_ReadPathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReadPathResponse& a, ReadPathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadPathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadPathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadPathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadPathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadPathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadPathResponse& from) {
    ReadPathResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadPathResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadPathResponse";
  }
  protected:
  explicit ReadPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 1,
  };
  // repeated bytes bucket = 1;
  int bucket_size() const;
  private:
  int _internal_bucket_size() const;
  public:
  void clear_bucket();
  const std::string& bucket(int index) const;
  std::string* mutable_bucket(int index);
  void set_bucket(int index, const std::string& value);
  void set_bucket(int index, std::string&& value);
  void set_bucket(int index, const char* value);
  void set_bucket(int index, const void* value, size_t size);
  std::string* add_bucket();
  void add_bucket(const std::string& value);
  void add_bucket(std::string&& value);
  void add_bucket(const char* value);
  void add_bucket(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bucket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bucket();
  private:
  const std::string& _internal_bucket(int index) const;
  std::string* _internal_add_bucket();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadPathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bucket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WritePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.WritePathRequest) */ {
 public:
  inline WritePathRequest() : WritePathRequest(nullptr) {}
  ~WritePathRequest() override;
  explicit PROTOBUF_CONSTEXPR WritePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePathRequest(const WritePathRequest& from);
  WritePathRequest(WritePathRequest&& from) noexcept
    : WritePathRequest() {
    *this = ::std::move(from);
  }

  inline WritePathRequest& operator=(const WritePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePathRequest& operator=(WritePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePathRequest* internal_default_instance() {
    return reinterpret_cast<const WritePathRequest*>(
               &_WritePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WritePathRequest& a, WritePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WritePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WritePathRequest& from) {
    WritePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WritePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.WritePathRequest";
  }
  protected:
  explicit WritePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kPathFieldNumber = 2,
    kLevelFieldNumber = 3,
    kTypeFieldNumber = 5,
    kOffsetFieldNumber = 6,
  };
  // repeated bytes bucket = 4;
  int bucket_size() const;
  private:
  int _internal_bucket_size() const;
  public:
  void clear_bucket();
  const std::string& bucket(int index) const;
  std::string* mutable_bucket(int index);
  void set_bucket(int index, const std::string& value);
  void set_bucket(int index, std::string&& value);
  void set_bucket(int index, const char* value);
  void set_bucket(int index, const void* value, size_t size);
  std::string* add_bucket();
  void add_bucket(const std::string& value);
  void add_bucket(std::string&& value);
  void add_bucket(const char* value);
  void add_bucket(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bucket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bucket();
  private:
  const std::string& _internal_bucket(int index) const;
  std::string* _internal_add_bucket();
  public:

  // .oram_impl.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::oram_impl::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::oram_impl::RequestHeader* release_header();
  ::oram_impl::RequestHeader* mutable_header();
  void set_allocated_header(::oram_impl::RequestHeader* header);
  private:
  const ::oram_impl::RequestHeader& _internal_header() const;
  ::oram_impl::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::oram_impl::RequestHeader* header);
  ::oram_impl::RequestHeader* unsafe_arena_release_header();

  // uint32 path = 2;
  void clear_path();
  uint32_t path() const;
  void set_path(uint32_t value);
  private:
  uint32_t _internal_path() const;
  void _internal_set_path(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // optional .oram_impl.Type type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::oram_impl::Type type() const;
  void set_type(::oram_impl::Type value);
  private:
  ::oram_impl::Type _internal_type() const;
  void _internal_set_type(::oram_impl::Type value);
  public:

  // optional uint32 offset = 6;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.WritePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bucket_;
    ::oram_impl::RequestHeader* header_;
    uint32_t path_;
    uint32_t level_;
    int type_;
    uint32_t offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WritePathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oram_impl.WritePathResponse) */ {
 public:
  inline WritePathResponse() : WritePathResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WritePathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePathResponse(const WritePathResponse& from);
  WritePathResponse(WritePathResponse&& from) noexcept
    : WritePathResponse() {
    *this = ::std::move(from);
  }

  inline WritePathResponse& operator=(const WritePathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePathResponse& operator=(WritePathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePathResponse* internal_default_instance() {
    return reinterpret_cast<const WritePathResponse*>(
               &_WritePathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WritePathResponse& a, WritePathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WritePathResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WritePathResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.WritePathResponse";
  }
  protected:
  explicit WritePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oram_impl.WritePathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// bytes instance_hash = 1;
inline void RequestHeader::clear_instance_hash() {
  _impl_.instance_hash_.ClearToEmpty();
}
inline const std::string& RequestHeader::instance_hash() const {
  // @@protoc_insertion_point(field_get:oram_impl.RequestHeader.instance_hash)
  return _internal_instance_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_instance_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.RequestHeader.instance_hash)
}
inline std::string* RequestHeader::mutable_instance_hash() {
  std::string* _s = _internal_mutable_instance_hash();
  // @@protoc_insertion_point(field_mutable:oram_impl.RequestHeader.instance_hash)
  return _s;
}
inline const std::string& RequestHeader::_internal_instance_hash() const {
  return _impl_.instance_hash_.Get();
}
inline void RequestHeader::_internal_set_instance_hash(const std::string& value) {
  
  _impl_.instance_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_instance_hash() {
  
  return _impl_.instance_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_instance_hash() {
  // @@protoc_insertion_point(field_release:oram_impl.RequestHeader.instance_hash)
  return _impl_.instance_hash_.Release();
}
inline void RequestHeader::set_allocated_instance_hash(std::string* instance_hash) {
  if (instance_hash != nullptr) {
    
  } else {
    
  }
  _impl_.instance_hash_.SetAllocated(instance_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_hash_.IsDefault()) {
    _impl_.instance_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.RequestHeader.instance_hash)
}

// bytes version = 2;
inline void RequestHeader::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& RequestHeader::version() const {
  // @@protoc_insertion_point(field_get:oram_impl.RequestHeader.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.RequestHeader.version)
}
inline std::string* RequestHeader::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:oram_impl.RequestHeader.version)
  return _s;
}
inline const std::string& RequestHeader::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RequestHeader::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_version() {
  // @@protoc_insertion_point(field_release:oram_impl.RequestHeader.version)
  return _impl_.version_.Release();
}
inline void RequestHeader::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.RequestHeader.version)
}

// uint32 id = 3;
inline void RequestHeader::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t RequestHeader::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t RequestHeader::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.RequestHeader.id)
  return _internal_id();
}
inline void RequestHeader::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void RequestHeader::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.RequestHeader.id)
}

// -------------------------------------------------------------------

// PrintOramTreeRequest

// uint32 id = 1;
inline void PrintOramTreeRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t PrintOramTreeRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t PrintOramTreeRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.PrintOramTreeRequest.id)
  return _internal_id();
}
inline void PrintOramTreeRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PrintOramTreeRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.PrintOramTreeRequest.id)
}

// -------------------------------------------------------------------

// HelloMessage

// bytes content = 1;
inline void HelloMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& HelloMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.HelloMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.HelloMessage.content)
}
inline std::string* HelloMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.HelloMessage.content)
  return _s;
}
inline const std::string& HelloMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void HelloMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.HelloMessage.content)
  return _impl_.content_.Release();
}
inline void HelloMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.HelloMessage.content)
}

// bytes iv = 2;
inline void HelloMessage::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& HelloMessage::iv() const {
  // @@protoc_insertion_point(field_get:oram_impl.HelloMessage.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.HelloMessage.iv)
}
inline std::string* HelloMessage::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:oram_impl.HelloMessage.iv)
  return _s;
}
inline const std::string& HelloMessage::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void HelloMessage::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloMessage::release_iv() {
  // @@protoc_insertion_point(field_release:oram_impl.HelloMessage.iv)
  return _impl_.iv_.Release();
}
inline void HelloMessage::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.HelloMessage.iv)
}

// -------------------------------------------------------------------

// KeyExchangeRequest

// bytes public_key_client = 1;
inline void KeyExchangeRequest::clear_public_key_client() {
  _impl_.public_key_client_.ClearToEmpty();
}
inline const std::string& KeyExchangeRequest::public_key_client() const {
  // @@protoc_insertion_point(field_get:oram_impl.KeyExchangeRequest.public_key_client)
  return _internal_public_key_client();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyExchangeRequest::set_public_key_client(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_client_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.KeyExchangeRequest.public_key_client)
}
inline std::string* KeyExchangeRequest::mutable_public_key_client() {
  std::string* _s = _internal_mutable_public_key_client();
  // @@protoc_insertion_point(field_mutable:oram_impl.KeyExchangeRequest.public_key_client)
  return _s;
}
inline const std::string& KeyExchangeRequest::_internal_public_key_client() const {
  return _impl_.public_key_client_.Get();
}
inline void KeyExchangeRequest::_internal_set_public_key_client(const std::string& value) {
  
  _impl_.public_key_client_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyExchangeRequest::_internal_mutable_public_key_client() {
  
  return _impl_.public_key_client_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyExchangeRequest::release_public_key_client() {
  // @@protoc_insertion_point(field_release:oram_impl.KeyExchangeRequest.public_key_client)
  return _impl_.public_key_client_.Release();
}
inline void KeyExchangeRequest::set_allocated_public_key_client(std::string* public_key_client) {
  if (public_key_client != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_client_.SetAllocated(public_key_client, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_client_.IsDefault()) {
    _impl_.public_key_client_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.KeyExchangeRequest.public_key_client)
}

// -------------------------------------------------------------------

// KeyExchangeResponse

// bytes public_key_server = 1;
inline void KeyExchangeResponse::clear_public_key_server() {
  _impl_.public_key_server_.ClearToEmpty();
}
inline const std::string& KeyExchangeResponse::public_key_server() const {
  // @@protoc_insertion_point(field_get:oram_impl.KeyExchangeResponse.public_key_server)
  return _internal_public_key_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyExchangeResponse::set_public_key_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_server_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.KeyExchangeResponse.public_key_server)
}
inline std::string* KeyExchangeResponse::mutable_public_key_server() {
  std::string* _s = _internal_mutable_public_key_server();
  // @@protoc_insertion_point(field_mutable:oram_impl.KeyExchangeResponse.public_key_server)
  return _s;
}
inline const std::string& KeyExchangeResponse::_internal_public_key_server() const {
  return _impl_.public_key_server_.Get();
}
inline void KeyExchangeResponse::_internal_set_public_key_server(const std::string& value) {
  
  _impl_.public_key_server_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyExchangeResponse::_internal_mutable_public_key_server() {
  
  return _impl_.public_key_server_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyExchangeResponse::release_public_key_server() {
  // @@protoc_insertion_point(field_release:oram_impl.KeyExchangeResponse.public_key_server)
  return _impl_.public_key_server_.Release();
}
inline void KeyExchangeResponse::set_allocated_public_key_server(std::string* public_key_server) {
  if (public_key_server != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_server_.SetAllocated(public_key_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_server_.IsDefault()) {
    _impl_.public_key_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.KeyExchangeResponse.public_key_server)
}

// -------------------------------------------------------------------

// InitFlatOramRequest

// .oram_impl.RequestHeader header = 1;
inline bool InitFlatOramRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool InitFlatOramRequest::has_header() const {
  return _internal_has_header();
}
inline void InitFlatOramRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& InitFlatOramRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& InitFlatOramRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.header)
  return _internal_header();
}
inline void InitFlatOramRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.InitFlatOramRequest.header)
}
inline ::oram_impl::RequestHeader* InitFlatOramRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* InitFlatOramRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.InitFlatOramRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* InitFlatOramRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* InitFlatOramRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.InitFlatOramRequest.header)
  return _msg;
}
inline void InitFlatOramRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.InitFlatOramRequest.header)
}

// uint32 capacity = 2;
inline void InitFlatOramRequest::clear_capacity() {
  _impl_.capacity_ = 0u;
}
inline uint32_t InitFlatOramRequest::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t InitFlatOramRequest::capacity() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.capacity)
  return _internal_capacity();
}
inline void InitFlatOramRequest::_internal_set_capacity(uint32_t value) {
  
  _impl_.capacity_ = value;
}
inline void InitFlatOramRequest::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitFlatOramRequest.capacity)
}

// uint32 block_size = 3;
inline void InitFlatOramRequest::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline uint32_t InitFlatOramRequest::_internal_block_size() const {
  return _impl_.block_size_;
}
inline uint32_t InitFlatOramRequest::block_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.block_size)
  return _internal_block_size();
}
inline void InitFlatOramRequest::_internal_set_block_size(uint32_t value) {
  
  _impl_.block_size_ = value;
}
inline void InitFlatOramRequest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitFlatOramRequest.block_size)
}

// -------------------------------------------------------------------

// InitSqrtOramRequest

// .oram_impl.RequestHeader header = 1;
inline bool InitSqrtOramRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool InitSqrtOramRequest::has_header() const {
  return _internal_has_header();
}
inline void InitSqrtOramRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& InitSqrtOramRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& InitSqrtOramRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitSqrtOramRequest.header)
  return _internal_header();
}
inline void InitSqrtOramRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.InitSqrtOramRequest.header)
}
inline ::oram_impl::RequestHeader* InitSqrtOramRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* InitSqrtOramRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.InitSqrtOramRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* InitSqrtOramRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* InitSqrtOramRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.InitSqrtOramRequest.header)
  return _msg;
}
inline void InitSqrtOramRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.InitSqrtOramRequest.header)
}

// uint32 capacity = 2;
inline void InitSqrtOramRequest::clear_capacity() {
  _impl_.capacity_ = 0u;
}
inline uint32_t InitSqrtOramRequest::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t InitSqrtOramRequest::capacity() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitSqrtOramRequest.capacity)
  return _internal_capacity();
}
inline void InitSqrtOramRequest::_internal_set_capacity(uint32_t value) {
  
  _impl_.capacity_ = value;
}
inline void InitSqrtOramRequest::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitSqrtOramRequest.capacity)
}

// uint32 squared_m = 3;
inline void InitSqrtOramRequest::clear_squared_m() {
  _impl_.squared_m_ = 0u;
}
inline uint32_t InitSqrtOramRequest::_internal_squared_m() const {
  return _impl_.squared_m_;
}
inline uint32_t InitSqrtOramRequest::squared_m() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitSqrtOramRequest.squared_m)
  return _internal_squared_m();
}
inline void InitSqrtOramRequest::_internal_set_squared_m(uint32_t value) {
  
  _impl_.squared_m_ = value;
}
inline void InitSqrtOramRequest::set_squared_m(uint32_t value) {
  _internal_set_squared_m(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitSqrtOramRequest.squared_m)
}

// uint32 block_size = 4;
inline void InitSqrtOramRequest::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline uint32_t InitSqrtOramRequest::_internal_block_size() const {
  return _impl_.block_size_;
}
inline uint32_t InitSqrtOramRequest::block_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitSqrtOramRequest.block_size)
  return _internal_block_size();
}
inline void InitSqrtOramRequest::_internal_set_block_size(uint32_t value) {
  
  _impl_.block_size_ = value;
}
inline void InitSqrtOramRequest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitSqrtOramRequest.block_size)
}

// -------------------------------------------------------------------

// FlatVectorMessage

// .oram_impl.RequestHeader header = 1;
inline bool FlatVectorMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FlatVectorMessage::has_header() const {
  return _internal_has_header();
}
inline void FlatVectorMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& FlatVectorMessage::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& FlatVectorMessage::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.FlatVectorMessage.header)
  return _internal_header();
}
inline void FlatVectorMessage::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.FlatVectorMessage.header)
}
inline ::oram_impl::RequestHeader* FlatVectorMessage::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* FlatVectorMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.FlatVectorMessage.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* FlatVectorMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* FlatVectorMessage::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.FlatVectorMessage.header)
  return _msg;
}
inline void FlatVectorMessage::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.FlatVectorMessage.header)
}

// bytes content = 2;
inline void FlatVectorMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FlatVectorMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.FlatVectorMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatVectorMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.FlatVectorMessage.content)
}
inline std::string* FlatVectorMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.FlatVectorMessage.content)
  return _s;
}
inline const std::string& FlatVectorMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FlatVectorMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatVectorMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatVectorMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.FlatVectorMessage.content)
  return _impl_.content_.Release();
}
inline void FlatVectorMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.FlatVectorMessage.content)
}

// -------------------------------------------------------------------

// SqrtMessage

// .oram_impl.RequestHeader header = 1;
inline bool SqrtMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SqrtMessage::has_header() const {
  return _internal_has_header();
}
inline void SqrtMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& SqrtMessage::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& SqrtMessage::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.SqrtMessage.header)
  return _internal_header();
}
inline void SqrtMessage::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.SqrtMessage.header)
}
inline ::oram_impl::RequestHeader* SqrtMessage::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* SqrtMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.SqrtMessage.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* SqrtMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* SqrtMessage::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.SqrtMessage.header)
  return _msg;
}
inline void SqrtMessage::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.SqrtMessage.header)
}

// bytes content = 2;
inline void SqrtMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& SqrtMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.SqrtMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqrtMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.SqrtMessage.content)
}
inline std::string* SqrtMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.SqrtMessage.content)
  return _s;
}
inline const std::string& SqrtMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void SqrtMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* SqrtMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* SqrtMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.SqrtMessage.content)
  return _impl_.content_.Release();
}
inline void SqrtMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.SqrtMessage.content)
}

// -------------------------------------------------------------------

// WriteSqrtMessage

// .oram_impl.RequestHeader header = 1;
inline bool WriteSqrtMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool WriteSqrtMessage::has_header() const {
  return _internal_has_header();
}
inline void WriteSqrtMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& WriteSqrtMessage::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& WriteSqrtMessage::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.WriteSqrtMessage.header)
  return _internal_header();
}
inline void WriteSqrtMessage::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.WriteSqrtMessage.header)
}
inline ::oram_impl::RequestHeader* WriteSqrtMessage::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* WriteSqrtMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.WriteSqrtMessage.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* WriteSqrtMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* WriteSqrtMessage::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.WriteSqrtMessage.header)
  return _msg;
}
inline void WriteSqrtMessage::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.WriteSqrtMessage.header)
}

// bytes content = 2;
inline void WriteSqrtMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& WriteSqrtMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.WriteSqrtMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteSqrtMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.WriteSqrtMessage.content)
}
inline std::string* WriteSqrtMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.WriteSqrtMessage.content)
  return _s;
}
inline const std::string& WriteSqrtMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void WriteSqrtMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteSqrtMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteSqrtMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.WriteSqrtMessage.content)
  return _impl_.content_.Release();
}
inline void WriteSqrtMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.WriteSqrtMessage.content)
}

// bool write_to_cache = 3;
inline void WriteSqrtMessage::clear_write_to_cache() {
  _impl_.write_to_cache_ = false;
}
inline bool WriteSqrtMessage::_internal_write_to_cache() const {
  return _impl_.write_to_cache_;
}
inline bool WriteSqrtMessage::write_to_cache() const {
  // @@protoc_insertion_point(field_get:oram_impl.WriteSqrtMessage.write_to_cache)
  return _internal_write_to_cache();
}
inline void WriteSqrtMessage::_internal_set_write_to_cache(bool value) {
  
  _impl_.write_to_cache_ = value;
}
inline void WriteSqrtMessage::set_write_to_cache(bool value) {
  _internal_set_write_to_cache(value);
  // @@protoc_insertion_point(field_set:oram_impl.WriteSqrtMessage.write_to_cache)
}

// -------------------------------------------------------------------

// SqrtPermMessage

// .oram_impl.RequestHeader header = 1;
inline bool SqrtPermMessage::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SqrtPermMessage::has_header() const {
  return _internal_has_header();
}
inline void SqrtPermMessage::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& SqrtPermMessage::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& SqrtPermMessage::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.SqrtPermMessage.header)
  return _internal_header();
}
inline void SqrtPermMessage::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.SqrtPermMessage.header)
}
inline ::oram_impl::RequestHeader* SqrtPermMessage::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* SqrtPermMessage::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.SqrtPermMessage.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* SqrtPermMessage::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* SqrtPermMessage::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.SqrtPermMessage.header)
  return _msg;
}
inline void SqrtPermMessage::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.SqrtPermMessage.header)
}

// repeated bytes content = 2;
inline int SqrtPermMessage::_internal_content_size() const {
  return _impl_.content_.size();
}
inline int SqrtPermMessage::content_size() const {
  return _internal_content_size();
}
inline void SqrtPermMessage::clear_content() {
  _impl_.content_.Clear();
}
inline std::string* SqrtPermMessage::add_content() {
  std::string* _s = _internal_add_content();
  // @@protoc_insertion_point(field_add_mutable:oram_impl.SqrtPermMessage.content)
  return _s;
}
inline const std::string& SqrtPermMessage::_internal_content(int index) const {
  return _impl_.content_.Get(index);
}
inline const std::string& SqrtPermMessage::content(int index) const {
  // @@protoc_insertion_point(field_get:oram_impl.SqrtPermMessage.content)
  return _internal_content(index);
}
inline std::string* SqrtPermMessage::mutable_content(int index) {
  // @@protoc_insertion_point(field_mutable:oram_impl.SqrtPermMessage.content)
  return _impl_.content_.Mutable(index);
}
inline void SqrtPermMessage::set_content(int index, const std::string& value) {
  _impl_.content_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::set_content(int index, std::string&& value) {
  _impl_.content_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::set_content(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.content_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::set_content(int index, const void* value, size_t size) {
  _impl_.content_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oram_impl.SqrtPermMessage.content)
}
inline std::string* SqrtPermMessage::_internal_add_content() {
  return _impl_.content_.Add();
}
inline void SqrtPermMessage::add_content(const std::string& value) {
  _impl_.content_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::add_content(std::string&& value) {
  _impl_.content_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::add_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.content_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oram_impl.SqrtPermMessage.content)
}
inline void SqrtPermMessage::add_content(const void* value, size_t size) {
  _impl_.content_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oram_impl.SqrtPermMessage.content)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SqrtPermMessage::content() const {
  // @@protoc_insertion_point(field_list:oram_impl.SqrtPermMessage.content)
  return _impl_.content_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SqrtPermMessage::mutable_content() {
  // @@protoc_insertion_point(field_mutable_list:oram_impl.SqrtPermMessage.content)
  return &_impl_.content_;
}

// -------------------------------------------------------------------

// InitTreeOramRequest

// .oram_impl.RequestHeader header = 1;
inline bool InitTreeOramRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool InitTreeOramRequest::has_header() const {
  return _internal_has_header();
}
inline void InitTreeOramRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& InitTreeOramRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& InitTreeOramRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.header)
  return _internal_header();
}
inline void InitTreeOramRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.InitTreeOramRequest.header)
}
inline ::oram_impl::RequestHeader* InitTreeOramRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* InitTreeOramRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.InitTreeOramRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* InitTreeOramRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* InitTreeOramRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.InitTreeOramRequest.header)
  return _msg;
}
inline void InitTreeOramRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.InitTreeOramRequest.header)
}

// uint32 bucket_size = 2;
inline void InitTreeOramRequest::clear_bucket_size() {
  _impl_.bucket_size_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_bucket_size() const {
  return _impl_.bucket_size_;
}
inline uint32_t InitTreeOramRequest::bucket_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.bucket_size)
  return _internal_bucket_size();
}
inline void InitTreeOramRequest::_internal_set_bucket_size(uint32_t value) {
  
  _impl_.bucket_size_ = value;
}
inline void InitTreeOramRequest::set_bucket_size(uint32_t value) {
  _internal_set_bucket_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.bucket_size)
}

// uint32 bucket_num = 3;
inline void InitTreeOramRequest::clear_bucket_num() {
  _impl_.bucket_num_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_bucket_num() const {
  return _impl_.bucket_num_;
}
inline uint32_t InitTreeOramRequest::bucket_num() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.bucket_num)
  return _internal_bucket_num();
}
inline void InitTreeOramRequest::_internal_set_bucket_num(uint32_t value) {
  
  _impl_.bucket_num_ = value;
}
inline void InitTreeOramRequest::set_bucket_num(uint32_t value) {
  _internal_set_bucket_num(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.bucket_num)
}

// uint32 block_size = 4;
inline void InitTreeOramRequest::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_block_size() const {
  return _impl_.block_size_;
}
inline uint32_t InitTreeOramRequest::block_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.block_size)
  return _internal_block_size();
}
inline void InitTreeOramRequest::_internal_set_block_size(uint32_t value) {
  
  _impl_.block_size_ = value;
}
inline void InitTreeOramRequest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.block_size)
}

// -------------------------------------------------------------------

// ReadFlatRequest

// .oram_impl.RequestHeader header = 1;
inline bool ReadFlatRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ReadFlatRequest::has_header() const {
  return _internal_has_header();
}
inline void ReadFlatRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& ReadFlatRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& ReadFlatRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadFlatRequest.header)
  return _internal_header();
}
inline void ReadFlatRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.ReadFlatRequest.header)
}
inline ::oram_impl::RequestHeader* ReadFlatRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* ReadFlatRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.ReadFlatRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* ReadFlatRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* ReadFlatRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.ReadFlatRequest.header)
  return _msg;
}
inline void ReadFlatRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.ReadFlatRequest.header)
}

// -------------------------------------------------------------------

// ReadSqrtRequest

// .oram_impl.RequestHeader header = 1;
inline bool ReadSqrtRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ReadSqrtRequest::has_header() const {
  return _internal_has_header();
}
inline void ReadSqrtRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& ReadSqrtRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& ReadSqrtRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadSqrtRequest.header)
  return _internal_header();
}
inline void ReadSqrtRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.ReadSqrtRequest.header)
}
inline ::oram_impl::RequestHeader* ReadSqrtRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* ReadSqrtRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.ReadSqrtRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* ReadSqrtRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* ReadSqrtRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.ReadSqrtRequest.header)
  return _msg;
}
inline void ReadSqrtRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.ReadSqrtRequest.header)
}

// uint32 tag = 2;
inline void ReadSqrtRequest::clear_tag() {
  _impl_.tag_ = 0u;
}
inline uint32_t ReadSqrtRequest::_internal_tag() const {
  return _impl_.tag_;
}
inline uint32_t ReadSqrtRequest::tag() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadSqrtRequest.tag)
  return _internal_tag();
}
inline void ReadSqrtRequest::_internal_set_tag(uint32_t value) {
  
  _impl_.tag_ = value;
}
inline void ReadSqrtRequest::set_tag(uint32_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadSqrtRequest.tag)
}

// uint32 read_from = 3;
inline void ReadSqrtRequest::clear_read_from() {
  _impl_.read_from_ = 0u;
}
inline uint32_t ReadSqrtRequest::_internal_read_from() const {
  return _impl_.read_from_;
}
inline uint32_t ReadSqrtRequest::read_from() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadSqrtRequest.read_from)
  return _internal_read_from();
}
inline void ReadSqrtRequest::_internal_set_read_from(uint32_t value) {
  
  _impl_.read_from_ = value;
}
inline void ReadSqrtRequest::set_read_from(uint32_t value) {
  _internal_set_read_from(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadSqrtRequest.read_from)
}

// -------------------------------------------------------------------

// ReadPathRequest

// .oram_impl.RequestHeader header = 1;
inline bool ReadPathRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool ReadPathRequest::has_header() const {
  return _internal_has_header();
}
inline void ReadPathRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& ReadPathRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& ReadPathRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.header)
  return _internal_header();
}
inline void ReadPathRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.ReadPathRequest.header)
}
inline ::oram_impl::RequestHeader* ReadPathRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* ReadPathRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.ReadPathRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* ReadPathRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* ReadPathRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.ReadPathRequest.header)
  return _msg;
}
inline void ReadPathRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.ReadPathRequest.header)
}

// uint32 path = 2;
inline void ReadPathRequest::clear_path() {
  _impl_.path_ = 0u;
}
inline uint32_t ReadPathRequest::_internal_path() const {
  return _impl_.path_;
}
inline uint32_t ReadPathRequest::path() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.path)
  return _internal_path();
}
inline void ReadPathRequest::_internal_set_path(uint32_t value) {
  
  _impl_.path_ = value;
}
inline void ReadPathRequest::set_path(uint32_t value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathRequest.path)
}

// uint32 level = 3;
inline void ReadPathRequest::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t ReadPathRequest::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t ReadPathRequest::level() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.level)
  return _internal_level();
}
inline void ReadPathRequest::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void ReadPathRequest::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathRequest.level)
}

// -------------------------------------------------------------------

// ReadPathResponse

// repeated bytes bucket = 1;
inline int ReadPathResponse::_internal_bucket_size() const {
  return _impl_.bucket_.size();
}
inline int ReadPathResponse::bucket_size() const {
  return _internal_bucket_size();
}
inline void ReadPathResponse::clear_bucket() {
  _impl_.bucket_.Clear();
}
inline std::string* ReadPathResponse::add_bucket() {
  std::string* _s = _internal_add_bucket();
  // @@protoc_insertion_point(field_add_mutable:oram_impl.ReadPathResponse.bucket)
  return _s;
}
inline const std::string& ReadPathResponse::_internal_bucket(int index) const {
  return _impl_.bucket_.Get(index);
}
inline const std::string& ReadPathResponse::bucket(int index) const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathResponse.bucket)
  return _internal_bucket(index);
}
inline std::string* ReadPathResponse::mutable_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:oram_impl.ReadPathResponse.bucket)
  return _impl_.bucket_.Mutable(index);
}
inline void ReadPathResponse::set_bucket(int index, const std::string& value) {
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, std::string&& value) {
  _impl_.bucket_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, const void* value, size_t size) {
  _impl_.bucket_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oram_impl.ReadPathResponse.bucket)
}
inline std::string* ReadPathResponse::_internal_add_bucket() {
  return _impl_.bucket_.Add();
}
inline void ReadPathResponse::add_bucket(const std::string& value) {
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(std::string&& value) {
  _impl_.bucket_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(const void* value, size_t size) {
  _impl_.bucket_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oram_impl.ReadPathResponse.bucket)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReadPathResponse::bucket() const {
  // @@protoc_insertion_point(field_list:oram_impl.ReadPathResponse.bucket)
  return _impl_.bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReadPathResponse::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:oram_impl.ReadPathResponse.bucket)
  return &_impl_.bucket_;
}

// -------------------------------------------------------------------

// WritePathRequest

// .oram_impl.RequestHeader header = 1;
inline bool WritePathRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool WritePathRequest::has_header() const {
  return _internal_has_header();
}
inline void WritePathRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::oram_impl::RequestHeader& WritePathRequest::_internal_header() const {
  const ::oram_impl::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::oram_impl::RequestHeader&>(
      ::oram_impl::_RequestHeader_default_instance_);
}
inline const ::oram_impl::RequestHeader& WritePathRequest::header() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.header)
  return _internal_header();
}
inline void WritePathRequest::unsafe_arena_set_allocated_header(
    ::oram_impl::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:oram_impl.WritePathRequest.header)
}
inline ::oram_impl::RequestHeader* WritePathRequest::release_header() {
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::oram_impl::RequestHeader* WritePathRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:oram_impl.WritePathRequest.header)
  
  ::oram_impl::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::oram_impl::RequestHeader* WritePathRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::oram_impl::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::oram_impl::RequestHeader* WritePathRequest::mutable_header() {
  ::oram_impl::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:oram_impl.WritePathRequest.header)
  return _msg;
}
inline void WritePathRequest::set_allocated_header(::oram_impl::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:oram_impl.WritePathRequest.header)
}

// uint32 path = 2;
inline void WritePathRequest::clear_path() {
  _impl_.path_ = 0u;
}
inline uint32_t WritePathRequest::_internal_path() const {
  return _impl_.path_;
}
inline uint32_t WritePathRequest::path() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.path)
  return _internal_path();
}
inline void WritePathRequest::_internal_set_path(uint32_t value) {
  
  _impl_.path_ = value;
}
inline void WritePathRequest::set_path(uint32_t value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.path)
}

// uint32 level = 3;
inline void WritePathRequest::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t WritePathRequest::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t WritePathRequest::level() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.level)
  return _internal_level();
}
inline void WritePathRequest::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void WritePathRequest::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.level)
}

// repeated bytes bucket = 4;
inline int WritePathRequest::_internal_bucket_size() const {
  return _impl_.bucket_.size();
}
inline int WritePathRequest::bucket_size() const {
  return _internal_bucket_size();
}
inline void WritePathRequest::clear_bucket() {
  _impl_.bucket_.Clear();
}
inline std::string* WritePathRequest::add_bucket() {
  std::string* _s = _internal_add_bucket();
  // @@protoc_insertion_point(field_add_mutable:oram_impl.WritePathRequest.bucket)
  return _s;
}
inline const std::string& WritePathRequest::_internal_bucket(int index) const {
  return _impl_.bucket_.Get(index);
}
inline const std::string& WritePathRequest::bucket(int index) const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.bucket)
  return _internal_bucket(index);
}
inline std::string* WritePathRequest::mutable_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:oram_impl.WritePathRequest.bucket)
  return _impl_.bucket_.Mutable(index);
}
inline void WritePathRequest::set_bucket(int index, const std::string& value) {
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, std::string&& value) {
  _impl_.bucket_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, const void* value, size_t size) {
  _impl_.bucket_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oram_impl.WritePathRequest.bucket)
}
inline std::string* WritePathRequest::_internal_add_bucket() {
  return _impl_.bucket_.Add();
}
inline void WritePathRequest::add_bucket(const std::string& value) {
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(std::string&& value) {
  _impl_.bucket_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(const void* value, size_t size) {
  _impl_.bucket_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oram_impl.WritePathRequest.bucket)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WritePathRequest::bucket() const {
  // @@protoc_insertion_point(field_list:oram_impl.WritePathRequest.bucket)
  return _impl_.bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WritePathRequest::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:oram_impl.WritePathRequest.bucket)
  return &_impl_.bucket_;
}

// optional .oram_impl.Type type = 5;
inline bool WritePathRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WritePathRequest::has_type() const {
  return _internal_has_type();
}
inline void WritePathRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::oram_impl::Type WritePathRequest::_internal_type() const {
  return static_cast< ::oram_impl::Type >(_impl_.type_);
}
inline ::oram_impl::Type WritePathRequest::type() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.type)
  return _internal_type();
}
inline void WritePathRequest::_internal_set_type(::oram_impl::Type value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void WritePathRequest::set_type(::oram_impl::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.type)
}

// optional uint32 offset = 6;
inline bool WritePathRequest::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WritePathRequest::has_offset() const {
  return _internal_has_offset();
}
inline void WritePathRequest::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t WritePathRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t WritePathRequest::offset() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.offset)
  return _internal_offset();
}
inline void WritePathRequest::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}
inline void WritePathRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.offset)
}

// -------------------------------------------------------------------

// WritePathResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace oram_impl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::oram_impl::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::oram_impl::Type>() {
  return ::oram_impl::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
