// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace oram_impl {
class FlatVectorMessage;
struct FlatVectorMessageDefaultTypeInternal;
extern FlatVectorMessageDefaultTypeInternal _FlatVectorMessage_default_instance_;
class HelloMessage;
struct HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class InitFlatOramRequest;
struct InitFlatOramRequestDefaultTypeInternal;
extern InitFlatOramRequestDefaultTypeInternal _InitFlatOramRequest_default_instance_;
class InitTreeOramRequest;
struct InitTreeOramRequestDefaultTypeInternal;
extern InitTreeOramRequestDefaultTypeInternal _InitTreeOramRequest_default_instance_;
class KeyExchangeRequest;
struct KeyExchangeRequestDefaultTypeInternal;
extern KeyExchangeRequestDefaultTypeInternal _KeyExchangeRequest_default_instance_;
class KeyExchangeResponse;
struct KeyExchangeResponseDefaultTypeInternal;
extern KeyExchangeResponseDefaultTypeInternal _KeyExchangeResponse_default_instance_;
class PrintOramTreeRequest;
struct PrintOramTreeRequestDefaultTypeInternal;
extern PrintOramTreeRequestDefaultTypeInternal _PrintOramTreeRequest_default_instance_;
class ReadFlatRequest;
struct ReadFlatRequestDefaultTypeInternal;
extern ReadFlatRequestDefaultTypeInternal _ReadFlatRequest_default_instance_;
class ReadPathRequest;
struct ReadPathRequestDefaultTypeInternal;
extern ReadPathRequestDefaultTypeInternal _ReadPathRequest_default_instance_;
class ReadPathResponse;
struct ReadPathResponseDefaultTypeInternal;
extern ReadPathResponseDefaultTypeInternal _ReadPathResponse_default_instance_;
class WritePathRequest;
struct WritePathRequestDefaultTypeInternal;
extern WritePathRequestDefaultTypeInternal _WritePathRequest_default_instance_;
class WritePathResponse;
struct WritePathResponseDefaultTypeInternal;
extern WritePathResponseDefaultTypeInternal _WritePathResponse_default_instance_;
}  // namespace oram_impl
PROTOBUF_NAMESPACE_OPEN
template<> ::oram_impl::FlatVectorMessage* Arena::CreateMaybeMessage<::oram_impl::FlatVectorMessage>(Arena*);
template<> ::oram_impl::HelloMessage* Arena::CreateMaybeMessage<::oram_impl::HelloMessage>(Arena*);
template<> ::oram_impl::InitFlatOramRequest* Arena::CreateMaybeMessage<::oram_impl::InitFlatOramRequest>(Arena*);
template<> ::oram_impl::InitTreeOramRequest* Arena::CreateMaybeMessage<::oram_impl::InitTreeOramRequest>(Arena*);
template<> ::oram_impl::KeyExchangeRequest* Arena::CreateMaybeMessage<::oram_impl::KeyExchangeRequest>(Arena*);
template<> ::oram_impl::KeyExchangeResponse* Arena::CreateMaybeMessage<::oram_impl::KeyExchangeResponse>(Arena*);
template<> ::oram_impl::PrintOramTreeRequest* Arena::CreateMaybeMessage<::oram_impl::PrintOramTreeRequest>(Arena*);
template<> ::oram_impl::ReadFlatRequest* Arena::CreateMaybeMessage<::oram_impl::ReadFlatRequest>(Arena*);
template<> ::oram_impl::ReadPathRequest* Arena::CreateMaybeMessage<::oram_impl::ReadPathRequest>(Arena*);
template<> ::oram_impl::ReadPathResponse* Arena::CreateMaybeMessage<::oram_impl::ReadPathResponse>(Arena*);
template<> ::oram_impl::WritePathRequest* Arena::CreateMaybeMessage<::oram_impl::WritePathRequest>(Arena*);
template<> ::oram_impl::WritePathResponse* Arena::CreateMaybeMessage<::oram_impl::WritePathResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace oram_impl {

enum Type : int {
  kSequential = 0,
  kRandom = 1,
  kInit = 2,
  kNormal = 3,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = kSequential;
constexpr Type Type_MAX = kNormal;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class PrintOramTreeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.PrintOramTreeRequest) */ {
 public:
  inline PrintOramTreeRequest() : PrintOramTreeRequest(nullptr) {}
  ~PrintOramTreeRequest() override;
  explicit PROTOBUF_CONSTEXPR PrintOramTreeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintOramTreeRequest(const PrintOramTreeRequest& from);
  PrintOramTreeRequest(PrintOramTreeRequest&& from) noexcept
    : PrintOramTreeRequest() {
    *this = ::std::move(from);
  }

  inline PrintOramTreeRequest& operator=(const PrintOramTreeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintOramTreeRequest& operator=(PrintOramTreeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrintOramTreeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintOramTreeRequest* internal_default_instance() {
    return reinterpret_cast<const PrintOramTreeRequest*>(
               &_PrintOramTreeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PrintOramTreeRequest& a, PrintOramTreeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintOramTreeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintOramTreeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintOramTreeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintOramTreeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrintOramTreeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrintOramTreeRequest& from) {
    PrintOramTreeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrintOramTreeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.PrintOramTreeRequest";
  }
  protected:
  explicit PrintOramTreeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.PrintOramTreeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class HelloMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.HelloMessage) */ {
 public:
  inline HelloMessage() : HelloMessage(nullptr) {}
  ~HelloMessage() override;
  explicit PROTOBUF_CONSTEXPR HelloMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage(const HelloMessage& from);
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloMessage& from) {
    HelloMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.HelloMessage";
  }
  protected:
  explicit HelloMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kIvFieldNumber = 2,
  };
  // bytes content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // bytes iv = 2;
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.HelloMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class KeyExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.KeyExchangeRequest) */ {
 public:
  inline KeyExchangeRequest() : KeyExchangeRequest(nullptr) {}
  ~KeyExchangeRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyExchangeRequest(const KeyExchangeRequest& from);
  KeyExchangeRequest(KeyExchangeRequest&& from) noexcept
    : KeyExchangeRequest() {
    *this = ::std::move(from);
  }

  inline KeyExchangeRequest& operator=(const KeyExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyExchangeRequest& operator=(KeyExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const KeyExchangeRequest*>(
               &_KeyExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KeyExchangeRequest& a, KeyExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyExchangeRequest& from) {
    KeyExchangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.KeyExchangeRequest";
  }
  protected:
  explicit KeyExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyClientFieldNumber = 1,
  };
  // bytes public_key_client = 1;
  void clear_public_key_client();
  const std::string& public_key_client() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_client(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_client();
  PROTOBUF_NODISCARD std::string* release_public_key_client();
  void set_allocated_public_key_client(std::string* public_key_client);
  private:
  const std::string& _internal_public_key_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_client(const std::string& value);
  std::string* _internal_mutable_public_key_client();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.KeyExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_client_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class KeyExchangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.KeyExchangeResponse) */ {
 public:
  inline KeyExchangeResponse() : KeyExchangeResponse(nullptr) {}
  ~KeyExchangeResponse() override;
  explicit PROTOBUF_CONSTEXPR KeyExchangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyExchangeResponse(const KeyExchangeResponse& from);
  KeyExchangeResponse(KeyExchangeResponse&& from) noexcept
    : KeyExchangeResponse() {
    *this = ::std::move(from);
  }

  inline KeyExchangeResponse& operator=(const KeyExchangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyExchangeResponse& operator=(KeyExchangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyExchangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyExchangeResponse* internal_default_instance() {
    return reinterpret_cast<const KeyExchangeResponse*>(
               &_KeyExchangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyExchangeResponse& a, KeyExchangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyExchangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyExchangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyExchangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyExchangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyExchangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyExchangeResponse& from) {
    KeyExchangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyExchangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.KeyExchangeResponse";
  }
  protected:
  explicit KeyExchangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyServerFieldNumber = 1,
  };
  // bytes public_key_server = 1;
  void clear_public_key_server();
  const std::string& public_key_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key_server();
  PROTOBUF_NODISCARD std::string* release_public_key_server();
  void set_allocated_public_key_server(std::string* public_key_server);
  private:
  const std::string& _internal_public_key_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key_server(const std::string& value);
  std::string* _internal_mutable_public_key_server();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.KeyExchangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_server_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitFlatOramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.InitFlatOramRequest) */ {
 public:
  inline InitFlatOramRequest() : InitFlatOramRequest(nullptr) {}
  ~InitFlatOramRequest() override;
  explicit PROTOBUF_CONSTEXPR InitFlatOramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitFlatOramRequest(const InitFlatOramRequest& from);
  InitFlatOramRequest(InitFlatOramRequest&& from) noexcept
    : InitFlatOramRequest() {
    *this = ::std::move(from);
  }

  inline InitFlatOramRequest& operator=(const InitFlatOramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitFlatOramRequest& operator=(InitFlatOramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitFlatOramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitFlatOramRequest* internal_default_instance() {
    return reinterpret_cast<const InitFlatOramRequest*>(
               &_InitFlatOramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InitFlatOramRequest& a, InitFlatOramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitFlatOramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitFlatOramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitFlatOramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitFlatOramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitFlatOramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitFlatOramRequest& from) {
    InitFlatOramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitFlatOramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.InitFlatOramRequest";
  }
  protected:
  explicit InitFlatOramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kBlockSizeFieldNumber = 3,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 capacity = 2;
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // uint32 block_size = 3;
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.InitFlatOramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t capacity_;
    uint32_t block_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class FlatVectorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.FlatVectorMessage) */ {
 public:
  inline FlatVectorMessage() : FlatVectorMessage(nullptr) {}
  ~FlatVectorMessage() override;
  explicit PROTOBUF_CONSTEXPR FlatVectorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlatVectorMessage(const FlatVectorMessage& from);
  FlatVectorMessage(FlatVectorMessage&& from) noexcept
    : FlatVectorMessage() {
    *this = ::std::move(from);
  }

  inline FlatVectorMessage& operator=(const FlatVectorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlatVectorMessage& operator=(FlatVectorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlatVectorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlatVectorMessage* internal_default_instance() {
    return reinterpret_cast<const FlatVectorMessage*>(
               &_FlatVectorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FlatVectorMessage& a, FlatVectorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FlatVectorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlatVectorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlatVectorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlatVectorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlatVectorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlatVectorMessage& from) {
    FlatVectorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlatVectorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.FlatVectorMessage";
  }
  protected:
  explicit FlatVectorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.FlatVectorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class InitTreeOramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.InitTreeOramRequest) */ {
 public:
  inline InitTreeOramRequest() : InitTreeOramRequest(nullptr) {}
  ~InitTreeOramRequest() override;
  explicit PROTOBUF_CONSTEXPR InitTreeOramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitTreeOramRequest(const InitTreeOramRequest& from);
  InitTreeOramRequest(InitTreeOramRequest&& from) noexcept
    : InitTreeOramRequest() {
    *this = ::std::move(from);
  }

  inline InitTreeOramRequest& operator=(const InitTreeOramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitTreeOramRequest& operator=(InitTreeOramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitTreeOramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitTreeOramRequest* internal_default_instance() {
    return reinterpret_cast<const InitTreeOramRequest*>(
               &_InitTreeOramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InitTreeOramRequest& a, InitTreeOramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitTreeOramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitTreeOramRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitTreeOramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitTreeOramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitTreeOramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitTreeOramRequest& from) {
    InitTreeOramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitTreeOramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.InitTreeOramRequest";
  }
  protected:
  explicit InitTreeOramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kBucketSizeFieldNumber = 2,
    kBucketNumFieldNumber = 3,
    kBlockSizeFieldNumber = 4,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 bucket_size = 2;
  void clear_bucket_size();
  uint32_t bucket_size() const;
  void set_bucket_size(uint32_t value);
  private:
  uint32_t _internal_bucket_size() const;
  void _internal_set_bucket_size(uint32_t value);
  public:

  // uint32 bucket_num = 3;
  void clear_bucket_num();
  uint32_t bucket_num() const;
  void set_bucket_num(uint32_t value);
  private:
  uint32_t _internal_bucket_num() const;
  void _internal_set_bucket_num(uint32_t value);
  public:

  // uint32 block_size = 4;
  void clear_block_size();
  uint32_t block_size() const;
  void set_block_size(uint32_t value);
  private:
  uint32_t _internal_block_size() const;
  void _internal_set_block_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.InitTreeOramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t bucket_size_;
    uint32_t bucket_num_;
    uint32_t block_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadFlatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadFlatRequest) */ {
 public:
  inline ReadFlatRequest() : ReadFlatRequest(nullptr) {}
  ~ReadFlatRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadFlatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFlatRequest(const ReadFlatRequest& from);
  ReadFlatRequest(ReadFlatRequest&& from) noexcept
    : ReadFlatRequest() {
    *this = ::std::move(from);
  }

  inline ReadFlatRequest& operator=(const ReadFlatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFlatRequest& operator=(ReadFlatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFlatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFlatRequest* internal_default_instance() {
    return reinterpret_cast<const ReadFlatRequest*>(
               &_ReadFlatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadFlatRequest& a, ReadFlatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFlatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFlatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFlatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFlatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFlatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadFlatRequest& from) {
    ReadFlatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFlatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadFlatRequest";
  }
  protected:
  explicit ReadFlatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadFlatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadPathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadPathRequest) */ {
 public:
  inline ReadPathRequest() : ReadPathRequest(nullptr) {}
  ~ReadPathRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadPathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadPathRequest(const ReadPathRequest& from);
  ReadPathRequest(ReadPathRequest&& from) noexcept
    : ReadPathRequest() {
    *this = ::std::move(from);
  }

  inline ReadPathRequest& operator=(const ReadPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadPathRequest& operator=(ReadPathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadPathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadPathRequest* internal_default_instance() {
    return reinterpret_cast<const ReadPathRequest*>(
               &_ReadPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadPathRequest& a, ReadPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadPathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadPathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadPathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadPathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadPathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadPathRequest& from) {
    ReadPathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadPathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadPathRequest";
  }
  protected:
  explicit ReadPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 path = 2;
  void clear_path();
  uint32_t path() const;
  void set_path(uint32_t value);
  private:
  uint32_t _internal_path() const;
  void _internal_set_path(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadPathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    uint32_t path_;
    uint32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ReadPathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.ReadPathResponse) */ {
 public:
  inline ReadPathResponse() : ReadPathResponse(nullptr) {}
  ~ReadPathResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadPathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadPathResponse(const ReadPathResponse& from);
  ReadPathResponse(ReadPathResponse&& from) noexcept
    : ReadPathResponse() {
    *this = ::std::move(from);
  }

  inline ReadPathResponse& operator=(const ReadPathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadPathResponse& operator=(ReadPathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadPathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadPathResponse* internal_default_instance() {
    return reinterpret_cast<const ReadPathResponse*>(
               &_ReadPathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadPathResponse& a, ReadPathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadPathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadPathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadPathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadPathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadPathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadPathResponse& from) {
    ReadPathResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadPathResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.ReadPathResponse";
  }
  protected:
  explicit ReadPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 1,
  };
  // repeated bytes bucket = 1;
  int bucket_size() const;
  private:
  int _internal_bucket_size() const;
  public:
  void clear_bucket();
  const std::string& bucket(int index) const;
  std::string* mutable_bucket(int index);
  void set_bucket(int index, const std::string& value);
  void set_bucket(int index, std::string&& value);
  void set_bucket(int index, const char* value);
  void set_bucket(int index, const void* value, size_t size);
  std::string* add_bucket();
  void add_bucket(const std::string& value);
  void add_bucket(std::string&& value);
  void add_bucket(const char* value);
  void add_bucket(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bucket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bucket();
  private:
  const std::string& _internal_bucket(int index) const;
  std::string* _internal_add_bucket();
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.ReadPathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bucket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WritePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:oram_impl.WritePathRequest) */ {
 public:
  inline WritePathRequest() : WritePathRequest(nullptr) {}
  ~WritePathRequest() override;
  explicit PROTOBUF_CONSTEXPR WritePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePathRequest(const WritePathRequest& from);
  WritePathRequest(WritePathRequest&& from) noexcept
    : WritePathRequest() {
    *this = ::std::move(from);
  }

  inline WritePathRequest& operator=(const WritePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePathRequest& operator=(WritePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePathRequest* internal_default_instance() {
    return reinterpret_cast<const WritePathRequest*>(
               &_WritePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WritePathRequest& a, WritePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WritePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WritePathRequest& from) {
    WritePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WritePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.WritePathRequest";
  }
  protected:
  explicit WritePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 4,
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
    kLevelFieldNumber = 3,
    kTypeFieldNumber = 5,
    kOffsetFieldNumber = 6,
  };
  // repeated bytes bucket = 4;
  int bucket_size() const;
  private:
  int _internal_bucket_size() const;
  public:
  void clear_bucket();
  const std::string& bucket(int index) const;
  std::string* mutable_bucket(int index);
  void set_bucket(int index, const std::string& value);
  void set_bucket(int index, std::string&& value);
  void set_bucket(int index, const char* value);
  void set_bucket(int index, const void* value, size_t size);
  std::string* add_bucket();
  void add_bucket(const std::string& value);
  void add_bucket(std::string&& value);
  void add_bucket(const char* value);
  void add_bucket(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bucket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bucket();
  private:
  const std::string& _internal_bucket(int index) const;
  std::string* _internal_add_bucket();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 path = 2;
  void clear_path();
  uint32_t path() const;
  void set_path(uint32_t value);
  private:
  uint32_t _internal_path() const;
  void _internal_set_path(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // optional .oram_impl.Type type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::oram_impl::Type type() const;
  void set_type(::oram_impl::Type value);
  private:
  ::oram_impl::Type _internal_type() const;
  void _internal_set_type(::oram_impl::Type value);
  public:

  // optional uint32 offset = 6;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:oram_impl.WritePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bucket_;
    uint32_t id_;
    uint32_t path_;
    uint32_t level_;
    int type_;
    uint32_t offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class WritePathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:oram_impl.WritePathResponse) */ {
 public:
  inline WritePathResponse() : WritePathResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WritePathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePathResponse(const WritePathResponse& from);
  WritePathResponse(WritePathResponse&& from) noexcept
    : WritePathResponse() {
    *this = ::std::move(from);
  }

  inline WritePathResponse& operator=(const WritePathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePathResponse& operator=(WritePathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePathResponse* internal_default_instance() {
    return reinterpret_cast<const WritePathResponse*>(
               &_WritePathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WritePathResponse& a, WritePathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WritePathResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WritePathResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "oram_impl.WritePathResponse";
  }
  protected:
  explicit WritePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:oram_impl.WritePathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PrintOramTreeRequest

// uint32 id = 1;
inline void PrintOramTreeRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t PrintOramTreeRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t PrintOramTreeRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.PrintOramTreeRequest.id)
  return _internal_id();
}
inline void PrintOramTreeRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void PrintOramTreeRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.PrintOramTreeRequest.id)
}

// -------------------------------------------------------------------

// HelloMessage

// bytes content = 1;
inline void HelloMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& HelloMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.HelloMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.HelloMessage.content)
}
inline std::string* HelloMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.HelloMessage.content)
  return _s;
}
inline const std::string& HelloMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void HelloMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.HelloMessage.content)
  return _impl_.content_.Release();
}
inline void HelloMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.HelloMessage.content)
}

// bytes iv = 2;
inline void HelloMessage::clear_iv() {
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& HelloMessage::iv() const {
  // @@protoc_insertion_point(field_get:oram_impl.HelloMessage.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_iv(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.HelloMessage.iv)
}
inline std::string* HelloMessage::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:oram_impl.HelloMessage.iv)
  return _s;
}
inline const std::string& HelloMessage::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void HelloMessage::_internal_set_iv(const std::string& value) {
  
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_iv() {
  
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloMessage::release_iv() {
  // @@protoc_insertion_point(field_release:oram_impl.HelloMessage.iv)
  return _impl_.iv_.Release();
}
inline void HelloMessage::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    
  } else {
    
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.HelloMessage.iv)
}

// -------------------------------------------------------------------

// KeyExchangeRequest

// bytes public_key_client = 1;
inline void KeyExchangeRequest::clear_public_key_client() {
  _impl_.public_key_client_.ClearToEmpty();
}
inline const std::string& KeyExchangeRequest::public_key_client() const {
  // @@protoc_insertion_point(field_get:oram_impl.KeyExchangeRequest.public_key_client)
  return _internal_public_key_client();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyExchangeRequest::set_public_key_client(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_client_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.KeyExchangeRequest.public_key_client)
}
inline std::string* KeyExchangeRequest::mutable_public_key_client() {
  std::string* _s = _internal_mutable_public_key_client();
  // @@protoc_insertion_point(field_mutable:oram_impl.KeyExchangeRequest.public_key_client)
  return _s;
}
inline const std::string& KeyExchangeRequest::_internal_public_key_client() const {
  return _impl_.public_key_client_.Get();
}
inline void KeyExchangeRequest::_internal_set_public_key_client(const std::string& value) {
  
  _impl_.public_key_client_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyExchangeRequest::_internal_mutable_public_key_client() {
  
  return _impl_.public_key_client_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyExchangeRequest::release_public_key_client() {
  // @@protoc_insertion_point(field_release:oram_impl.KeyExchangeRequest.public_key_client)
  return _impl_.public_key_client_.Release();
}
inline void KeyExchangeRequest::set_allocated_public_key_client(std::string* public_key_client) {
  if (public_key_client != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_client_.SetAllocated(public_key_client, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_client_.IsDefault()) {
    _impl_.public_key_client_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.KeyExchangeRequest.public_key_client)
}

// -------------------------------------------------------------------

// KeyExchangeResponse

// bytes public_key_server = 1;
inline void KeyExchangeResponse::clear_public_key_server() {
  _impl_.public_key_server_.ClearToEmpty();
}
inline const std::string& KeyExchangeResponse::public_key_server() const {
  // @@protoc_insertion_point(field_get:oram_impl.KeyExchangeResponse.public_key_server)
  return _internal_public_key_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyExchangeResponse::set_public_key_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_key_server_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.KeyExchangeResponse.public_key_server)
}
inline std::string* KeyExchangeResponse::mutable_public_key_server() {
  std::string* _s = _internal_mutable_public_key_server();
  // @@protoc_insertion_point(field_mutable:oram_impl.KeyExchangeResponse.public_key_server)
  return _s;
}
inline const std::string& KeyExchangeResponse::_internal_public_key_server() const {
  return _impl_.public_key_server_.Get();
}
inline void KeyExchangeResponse::_internal_set_public_key_server(const std::string& value) {
  
  _impl_.public_key_server_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyExchangeResponse::_internal_mutable_public_key_server() {
  
  return _impl_.public_key_server_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyExchangeResponse::release_public_key_server() {
  // @@protoc_insertion_point(field_release:oram_impl.KeyExchangeResponse.public_key_server)
  return _impl_.public_key_server_.Release();
}
inline void KeyExchangeResponse::set_allocated_public_key_server(std::string* public_key_server) {
  if (public_key_server != nullptr) {
    
  } else {
    
  }
  _impl_.public_key_server_.SetAllocated(public_key_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_server_.IsDefault()) {
    _impl_.public_key_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.KeyExchangeResponse.public_key_server)
}

// -------------------------------------------------------------------

// InitFlatOramRequest

// uint32 id = 1;
inline void InitFlatOramRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t InitFlatOramRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t InitFlatOramRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.id)
  return _internal_id();
}
inline void InitFlatOramRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void InitFlatOramRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitFlatOramRequest.id)
}

// uint32 capacity = 2;
inline void InitFlatOramRequest::clear_capacity() {
  _impl_.capacity_ = 0u;
}
inline uint32_t InitFlatOramRequest::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t InitFlatOramRequest::capacity() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.capacity)
  return _internal_capacity();
}
inline void InitFlatOramRequest::_internal_set_capacity(uint32_t value) {
  
  _impl_.capacity_ = value;
}
inline void InitFlatOramRequest::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitFlatOramRequest.capacity)
}

// uint32 block_size = 3;
inline void InitFlatOramRequest::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline uint32_t InitFlatOramRequest::_internal_block_size() const {
  return _impl_.block_size_;
}
inline uint32_t InitFlatOramRequest::block_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitFlatOramRequest.block_size)
  return _internal_block_size();
}
inline void InitFlatOramRequest::_internal_set_block_size(uint32_t value) {
  
  _impl_.block_size_ = value;
}
inline void InitFlatOramRequest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitFlatOramRequest.block_size)
}

// -------------------------------------------------------------------

// FlatVectorMessage

// uint32 id = 1;
inline void FlatVectorMessage::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t FlatVectorMessage::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t FlatVectorMessage::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.FlatVectorMessage.id)
  return _internal_id();
}
inline void FlatVectorMessage::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void FlatVectorMessage::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.FlatVectorMessage.id)
}

// bytes content = 2;
inline void FlatVectorMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FlatVectorMessage::content() const {
  // @@protoc_insertion_point(field_get:oram_impl.FlatVectorMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatVectorMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:oram_impl.FlatVectorMessage.content)
}
inline std::string* FlatVectorMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:oram_impl.FlatVectorMessage.content)
  return _s;
}
inline const std::string& FlatVectorMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FlatVectorMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatVectorMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatVectorMessage::release_content() {
  // @@protoc_insertion_point(field_release:oram_impl.FlatVectorMessage.content)
  return _impl_.content_.Release();
}
inline void FlatVectorMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:oram_impl.FlatVectorMessage.content)
}

// -------------------------------------------------------------------

// InitTreeOramRequest

// uint32 id = 1;
inline void InitTreeOramRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t InitTreeOramRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.id)
  return _internal_id();
}
inline void InitTreeOramRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void InitTreeOramRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.id)
}

// uint32 bucket_size = 2;
inline void InitTreeOramRequest::clear_bucket_size() {
  _impl_.bucket_size_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_bucket_size() const {
  return _impl_.bucket_size_;
}
inline uint32_t InitTreeOramRequest::bucket_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.bucket_size)
  return _internal_bucket_size();
}
inline void InitTreeOramRequest::_internal_set_bucket_size(uint32_t value) {
  
  _impl_.bucket_size_ = value;
}
inline void InitTreeOramRequest::set_bucket_size(uint32_t value) {
  _internal_set_bucket_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.bucket_size)
}

// uint32 bucket_num = 3;
inline void InitTreeOramRequest::clear_bucket_num() {
  _impl_.bucket_num_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_bucket_num() const {
  return _impl_.bucket_num_;
}
inline uint32_t InitTreeOramRequest::bucket_num() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.bucket_num)
  return _internal_bucket_num();
}
inline void InitTreeOramRequest::_internal_set_bucket_num(uint32_t value) {
  
  _impl_.bucket_num_ = value;
}
inline void InitTreeOramRequest::set_bucket_num(uint32_t value) {
  _internal_set_bucket_num(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.bucket_num)
}

// uint32 block_size = 4;
inline void InitTreeOramRequest::clear_block_size() {
  _impl_.block_size_ = 0u;
}
inline uint32_t InitTreeOramRequest::_internal_block_size() const {
  return _impl_.block_size_;
}
inline uint32_t InitTreeOramRequest::block_size() const {
  // @@protoc_insertion_point(field_get:oram_impl.InitTreeOramRequest.block_size)
  return _internal_block_size();
}
inline void InitTreeOramRequest::_internal_set_block_size(uint32_t value) {
  
  _impl_.block_size_ = value;
}
inline void InitTreeOramRequest::set_block_size(uint32_t value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:oram_impl.InitTreeOramRequest.block_size)
}

// -------------------------------------------------------------------

// ReadFlatRequest

// uint32 id = 1;
inline void ReadFlatRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t ReadFlatRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t ReadFlatRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadFlatRequest.id)
  return _internal_id();
}
inline void ReadFlatRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void ReadFlatRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadFlatRequest.id)
}

// -------------------------------------------------------------------

// ReadPathRequest

// uint32 id = 1;
inline void ReadPathRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t ReadPathRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t ReadPathRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.id)
  return _internal_id();
}
inline void ReadPathRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void ReadPathRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathRequest.id)
}

// uint32 path = 2;
inline void ReadPathRequest::clear_path() {
  _impl_.path_ = 0u;
}
inline uint32_t ReadPathRequest::_internal_path() const {
  return _impl_.path_;
}
inline uint32_t ReadPathRequest::path() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.path)
  return _internal_path();
}
inline void ReadPathRequest::_internal_set_path(uint32_t value) {
  
  _impl_.path_ = value;
}
inline void ReadPathRequest::set_path(uint32_t value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathRequest.path)
}

// uint32 level = 3;
inline void ReadPathRequest::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t ReadPathRequest::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t ReadPathRequest::level() const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathRequest.level)
  return _internal_level();
}
inline void ReadPathRequest::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void ReadPathRequest::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathRequest.level)
}

// -------------------------------------------------------------------

// ReadPathResponse

// repeated bytes bucket = 1;
inline int ReadPathResponse::_internal_bucket_size() const {
  return _impl_.bucket_.size();
}
inline int ReadPathResponse::bucket_size() const {
  return _internal_bucket_size();
}
inline void ReadPathResponse::clear_bucket() {
  _impl_.bucket_.Clear();
}
inline std::string* ReadPathResponse::add_bucket() {
  std::string* _s = _internal_add_bucket();
  // @@protoc_insertion_point(field_add_mutable:oram_impl.ReadPathResponse.bucket)
  return _s;
}
inline const std::string& ReadPathResponse::_internal_bucket(int index) const {
  return _impl_.bucket_.Get(index);
}
inline const std::string& ReadPathResponse::bucket(int index) const {
  // @@protoc_insertion_point(field_get:oram_impl.ReadPathResponse.bucket)
  return _internal_bucket(index);
}
inline std::string* ReadPathResponse::mutable_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:oram_impl.ReadPathResponse.bucket)
  return _impl_.bucket_.Mutable(index);
}
inline void ReadPathResponse::set_bucket(int index, const std::string& value) {
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, std::string&& value) {
  _impl_.bucket_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::set_bucket(int index, const void* value, size_t size) {
  _impl_.bucket_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oram_impl.ReadPathResponse.bucket)
}
inline std::string* ReadPathResponse::_internal_add_bucket() {
  return _impl_.bucket_.Add();
}
inline void ReadPathResponse::add_bucket(const std::string& value) {
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(std::string&& value) {
  _impl_.bucket_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oram_impl.ReadPathResponse.bucket)
}
inline void ReadPathResponse::add_bucket(const void* value, size_t size) {
  _impl_.bucket_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oram_impl.ReadPathResponse.bucket)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReadPathResponse::bucket() const {
  // @@protoc_insertion_point(field_list:oram_impl.ReadPathResponse.bucket)
  return _impl_.bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReadPathResponse::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:oram_impl.ReadPathResponse.bucket)
  return &_impl_.bucket_;
}

// -------------------------------------------------------------------

// WritePathRequest

// uint32 id = 1;
inline void WritePathRequest::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t WritePathRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t WritePathRequest::id() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.id)
  return _internal_id();
}
inline void WritePathRequest::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void WritePathRequest::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.id)
}

// uint32 path = 2;
inline void WritePathRequest::clear_path() {
  _impl_.path_ = 0u;
}
inline uint32_t WritePathRequest::_internal_path() const {
  return _impl_.path_;
}
inline uint32_t WritePathRequest::path() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.path)
  return _internal_path();
}
inline void WritePathRequest::_internal_set_path(uint32_t value) {
  
  _impl_.path_ = value;
}
inline void WritePathRequest::set_path(uint32_t value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.path)
}

// uint32 level = 3;
inline void WritePathRequest::clear_level() {
  _impl_.level_ = 0u;
}
inline uint32_t WritePathRequest::_internal_level() const {
  return _impl_.level_;
}
inline uint32_t WritePathRequest::level() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.level)
  return _internal_level();
}
inline void WritePathRequest::_internal_set_level(uint32_t value) {
  
  _impl_.level_ = value;
}
inline void WritePathRequest::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.level)
}

// repeated bytes bucket = 4;
inline int WritePathRequest::_internal_bucket_size() const {
  return _impl_.bucket_.size();
}
inline int WritePathRequest::bucket_size() const {
  return _internal_bucket_size();
}
inline void WritePathRequest::clear_bucket() {
  _impl_.bucket_.Clear();
}
inline std::string* WritePathRequest::add_bucket() {
  std::string* _s = _internal_add_bucket();
  // @@protoc_insertion_point(field_add_mutable:oram_impl.WritePathRequest.bucket)
  return _s;
}
inline const std::string& WritePathRequest::_internal_bucket(int index) const {
  return _impl_.bucket_.Get(index);
}
inline const std::string& WritePathRequest::bucket(int index) const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.bucket)
  return _internal_bucket(index);
}
inline std::string* WritePathRequest::mutable_bucket(int index) {
  // @@protoc_insertion_point(field_mutable:oram_impl.WritePathRequest.bucket)
  return _impl_.bucket_.Mutable(index);
}
inline void WritePathRequest::set_bucket(int index, const std::string& value) {
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, std::string&& value) {
  _impl_.bucket_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::set_bucket(int index, const void* value, size_t size) {
  _impl_.bucket_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:oram_impl.WritePathRequest.bucket)
}
inline std::string* WritePathRequest::_internal_add_bucket() {
  return _impl_.bucket_.Add();
}
inline void WritePathRequest::add_bucket(const std::string& value) {
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(std::string&& value) {
  _impl_.bucket_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bucket_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:oram_impl.WritePathRequest.bucket)
}
inline void WritePathRequest::add_bucket(const void* value, size_t size) {
  _impl_.bucket_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:oram_impl.WritePathRequest.bucket)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WritePathRequest::bucket() const {
  // @@protoc_insertion_point(field_list:oram_impl.WritePathRequest.bucket)
  return _impl_.bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WritePathRequest::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:oram_impl.WritePathRequest.bucket)
  return &_impl_.bucket_;
}

// optional .oram_impl.Type type = 5;
inline bool WritePathRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WritePathRequest::has_type() const {
  return _internal_has_type();
}
inline void WritePathRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::oram_impl::Type WritePathRequest::_internal_type() const {
  return static_cast< ::oram_impl::Type >(_impl_.type_);
}
inline ::oram_impl::Type WritePathRequest::type() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.type)
  return _internal_type();
}
inline void WritePathRequest::_internal_set_type(::oram_impl::Type value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void WritePathRequest::set_type(::oram_impl::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.type)
}

// optional uint32 offset = 6;
inline bool WritePathRequest::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WritePathRequest::has_offset() const {
  return _internal_has_offset();
}
inline void WritePathRequest::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t WritePathRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t WritePathRequest::offset() const {
  // @@protoc_insertion_point(field_get:oram_impl.WritePathRequest.offset)
  return _internal_offset();
}
inline void WritePathRequest::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}
inline void WritePathRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:oram_impl.WritePathRequest.offset)
}

// -------------------------------------------------------------------

// WritePathResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace oram_impl

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::oram_impl::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::oram_impl::Type>() {
  return ::oram_impl::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
